# Help

If you can, display help text _by default_, when `myapp subcommand` is run without any options.

A command without options, `myapp subcommand`, should produce an abbreviated version of the output from `myapp subcommand -h` and `myapp subcommand --help`.

The exception to this rule are for programs that are very simple and do one things that's very obvious (eg `ls`) or for programs that read input interactively (eg `cat`).

Otherwise concise help text should be the default output for all commands.

This concise help text should include only:

- A description of what the program does.
- One or two example invocations.
- Descriptions of the flags (if there are lots of them, list only the most useful ones).
- And instruction to pass the `--help` flag to get more information.

`jq` (a CLI JSON parser) does this well. When you type `jq`, it displays an introductory description and an example, then prompts you to run `jq --help` to see the full listing of flags.

```txt
$ jq
jq - commandline JSON processor [version 1.6]

Usage:    jq [options] <jq filter> [file...]
    jq [options] --args <jq filter> [strings...]
    jq [options] --jsonargs <jq filter> [JSON_TEXTS...]

jq is a tool for processing JSON inputs, applying the given filter to
its JSON text inputs and producing the filter's results as JSON on
standard output. ...

Example:

    $ echo '{"foo": 0}' | jq .
    {
        "foo": 0
    }

For a listing of options, use jq --help.
```

When `-h` or `--help` flags are passed, all other flags and arguments should be ignored and an extended version of the default help text should be outputted. Include the following:

- A support path for feedback and issues. A website or GitHub link in the top-level help text is good practice.

- Link to an online version of the documentation. This must be versioned documentation, corresponding to the installed version of the program. 

- Lead with examples. Users tend to use examples over other forms of documentation, so it is best to show these early in the help text, particularly the common use cases. If it's useful, include the program's expected output in the examples, too. If there are lots of usage examples, move most of them to external documentation.

- Display the most common flags and commands at the start of the help text. It's fine to have lots of flags, but if you've got some really common ones, display them first. For example, the Git command displays the commands for getting started and the most commonly used subcommands first:

```txt
$ git
usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status
```

- If possible, format your help text. Make headings bold, so they are easier to scan. Do this only if it can be done in a terminal-independent way. Users must not see escape characters.

- If the user did something wrong, like misspell a command name, and you can make a reasonable guess as to what they meant, suggest it. Do not run the operation you think the user meant, unless it is a documented alias. Making assumptions about a user's intention can be dangerous, especially where operations may result in modified state.

```txt
$ heroku pss
 â€º   Warning: pss is not a heroku command.
Did you mean ps? [y/n]:
```

- If your command is expecting to have something piped to it and `stdin` is an interactive terminal, display help immediately and quit. This means it doesn't just hang, like `cat`. Alternatively, you could print a log message to `stderr`.

Here's an excellent example of help output from the `heroku` program:

```txt
$ heroku apps --help
list your apps

USAGE
  $ heroku apps

OPTIONS
  -A, --all          include apps in all teams
  -p, --personal     list apps in personal account when a default team is set
  -s, --space=space  filter by space
  -t, --team=team    team to use
  --json             output in json format

EXAMPLES
  $ heroku apps
  === My Apps
  example
  example2

  === Collaborated Apps
  theirapp   other@owner.name

COMMANDS
  apps:create     creates a new app
  apps:destroy    permanently destroy an app
  apps:errors     view app errors
  apps:favorites  list favorited apps
  apps:info       show detailed app information
  apps:join       add yourself to a team app
  apps:leave      remove yourself from a team app
  apps:lock       prevent team members from joining an app
  apps:open       open the app in a web browser
  apps:rename     rename an app
  apps:stacks     show the list of available stacks
  apps:transfer   transfer applications to another user or team
  apps:unlock     unlock an app so any team member can join
```

Finally, consider also providing man pages. These are UNIX's original system of documentation, and they're still in use today. Many users reflexively check `my mycmd` as a first step when trying to learn a new tool. However, not everyone knows about `man`, and it doesn't work on all platforms. For this reason, man pages are an optional extra, and all documentation must be available via the tool directly.
